# Принцип подстановки Барбары Лисков (LSP, Liskov substitution Principle)
# Если есть родительский и дочерний классы, то можно использовать родительский класс в любых местах, где мы ожидаем использование родительского класса. Другими словами, и тот, и другой класс мы можем использовать, и при этом программа будет оставаться рабочей.
# И у класса родительского, и у дочернего класса при этом есть объекты,
# которые мы используем с какими-то функциями. Например, "класс родителя.fly", можем заменить
# его на "класс потомка.fly", и ошибки это вызывать не должно. Это и есть принцип подстановки.

class Bird():
    def init(self, name): self.name = name
    def fly(self): print('птица летает')

# Но если мы захотим создать пингвина, мы должны учесть, что пингвины летать не умеют.
# В коде же мы указали, что все птицы умеют летать — значит после создания класса
# “пингвин” он будет наследовать функцию полёта от базового класса Bird.
# В данном случае у нас есть несколько вариантов решения проблемы.
# Мы можем переопределить методы для класса пингвина. Однако лучшим подходом будет
# изменение структуры нашей программы.
# Создадим класс пингвина: class Ping(Bird): pass
#
# Теперь создадим птицу Сара класса пингвин: p = Ping ("Сара")
#
# Создадим для пингвина функцию fly, для этого пропишем:
#
# p.fly()